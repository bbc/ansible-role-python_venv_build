---
# Copyright 2018, Rackspace US, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# TODO(odyssey4me):
# 1. Cater for Logan's model where we must just extract
#    over the existing folder without wiping it out first.
# 2. Also, wiping the directory out from under it probably
#    wrecks the service while it's running. We should figure
#    out a better way of atomically replacing the venv without
#    ripping the folder out from under it.

- name: Install distro packages
  package:
    name: "{{ distro_package_list }}"
    state: "{{ distro_package_state }}"
    update_cache: "{{ (ansible_pkg_mgr in ['apt', 'zypper']) | ternary('yes', omit) }}"
    cache_valid_time: "{{ (ansible_pkg_mgr == 'apt') | ternary(distro_cache_valid_time, omit) }}"
  register: _install_distro_packages
  until: _install_distro_packages | success
  retries: 5
  delay: 2

- name: Install required pip packages on the host
  pip:
    name: "{{ host_pip_packages }}"
    state: latest
    extra_args: >-
      {{ pip_install_constraints }}
      {{ pip_install_options }}
  register: _install_host_pip_packages
  until: _install_host_pip_packages | success
  retries: 5
  delay: 2

- name: Ensure that venv_download_path exists on the deployment host
  file:
    path: "{{ venv_download_path }}/{{ venv_destination_path | dirname }}"
    state: directory
    owner: "{{ venv_download_path_owner }}"
  delegate_to: localhost
  run_once: yes

- name: Check if venv is present on the deployment host
  stat:
    path: "{{ venv_download_path }}/{{ venv_destination_path }}.tgz"
    get_attributes: no
    get_checksum: no
    get_md5: no
    get_mime: no
  register: _venv_tgz
  delegate_to: localhost
  run_once: yes

- name: Copy the venv checksum file to the target host
  copy:
    src: "{{ venv_download_path }}/{{ venv_destination_path }}.checksum"
    dest: "{{ venv_destination_path | dirname }}"
  register: _venv_checksum_copy
  when:
    - _venv_tgz.stat.exists | bool

# TODO(odyssey4me):
# 1. Cater for Logan's model where we must just extract
#    over the existing folder without wiping it out first.
# 2. Also, removing it like this probably wrecks the service
#    while it's running. We should figure out a better way
#    of atomically replacing the venv without ripping the
#    folder out from under it.

# Due to our Ansible strategy, a skipped task does not have
# a dictionary result. As such we validate that the register
# is a mapping (dict).
- name: Remove existing venv on target host if it is changing
  file:
    path: "{{ venv_destination_path }}"
    state: absent
  when:
    - _venv_checksum_copy is mapping
    - _venv_checksum_copy | changed

- name: Create venv directory on the target host
  file:
    path: "{{ venv_destination_path }}"
    state: directory
  register: _create_venv_dir

# Due to our Ansible strategy, a skipped task does not have
# a dictionary result. As such we validate that the register
# is a mapping (dict).
- name: Unarchive pre-built venv
  unarchive:
    src: "{{ venv_download_path }}/{{ venv_destination_path }}.tgz"
    dest: "{{ venv_destination_path }}"
    remote_src: no
  when:
    - _venv_checksum_copy is mapping
    - _venv_checksum_copy | changed
  notify:
    - Manage LB
    - Restart services

#TODO(odyssey4me):
# Split the venv build into multiple parts:
# 1. Create the venv without pip, setuptools, wheel
# 2. Use get-pip.py to install the right versions
#    of pip, setuptools, wheel into the venv
# 3. Install the packages into the venv

- name: Build venv
  pip:
    name: "{{ venv_pip_packages }}"
    state: latest
    virtualenv: "{{ venv_destination_path }}"
    virtualenv_site_packages: "no"
    extra_args: >-
      {{ pip_install_venv_constraints }}
      {{ pip_install_constraints }}
      {{ pip_install_options }}
  register: _install_venv_pip_packages
  until: _install_venv_pip_packages | success
  retries: 5
  delay: 2
  when:
    - not _venv_tgz.stat.exists | bool
  notify:
    - Manage LB
    - Restart services

# Due to our Ansible strategy, a skipped task does not have
# a dictionary result. As such we validate that the register
# is a mapping (dict).
- name: Update virtualenv python and paths
  shell: |
    sed -si '1s/^.*python.*$/#!{{ (venv_destination_path ~ '/bin') | replace ('/','\/') }}\/python/' {{ venv_destination_path }}/bin/*
    virtualenv {{ venv_destination_path }}
  when:
    - _venv_checksum_copy is mapping
    - _venv_checksum_copy | changed
  tags:
    - skip_ansible_lint

# Due to our Ansible strategy, a skipped task does not have
# a dictionary result. As such we validate that the register
# is a mapping (dict).
- name: Clean up the virtualenv before packaging
  shell: |
    find {{ venv_destination_path }}/bin -type f -name '*.pyc' -delete
  when:
    - _install_venv_pip_packages is mapping
    - _install_venv_pip_packages | changed

# Note(odyssey4me):
# We purposefully use shel instead of the archive module
# here. The archive module's output is far too verbose to
# be practical when debugging.
#
# Due to our Ansible strategy, a skipped task does not have
# a dictionary result. As such we validate that the register
# is a mapping (dict).
- name: Package venv
  shell: |
    tar czf '{{ venv_destination_path }}.tgz' -C '{{ venv_destination_path }}' .
  args:
    chdir: "{{ venv_destination_path }}"
    executable: /bin/bash
    warn: no
  register: _venv_package_build
  when:
    - _install_venv_pip_packages is mapping
    - _install_venv_pip_packages | changed

# Due to our Ansible strategy, a skipped task does not have
# a dictionary result. As such we validate that the register
# is a mapping (dict).
- name: Prepare checksum for packaged venv
  shell: |
    sha1sum '{{ venv_destination_path }}.tgz' | awk '{print $1}' > '{{ venv_destination_path }}.checksum'
  args:
    executable: /bin/bash
  when:
    - _venv_package_build is mapping
    - _venv_package_build | changed

# Due to our Ansible strategy, a skipped task does not have
# a dictionary result. As such we validate that the register
# is a mapping (dict).
- name: Copy the packaged venv and checksum file to the deployment host
  fetch:
    src: "{{ item.src }}"
    dest: "{{ item.dest }}"
    flat: yes
  with_items:
    - src: "{{ venv_destination_path }}.tgz"
      dest: "{{ venv_download_path }}/{{ venv_destination_path }}.tgz"
    - src: "{{ venv_destination_path }}.checksum"
      dest: "{{ venv_download_path }}/{{ venv_destination_path }}.checksum"
  when:
    - _venv_package_build is mapping
    - _venv_package_build | changed
